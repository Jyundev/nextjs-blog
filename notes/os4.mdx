---
title: "프로세스 스케줄링"
publishedAt: "2025-10-07"
summary: "Process Scheduling"
tags: ["CS", "OS"]
---

_하루에 하나씩 정리하는 CS 지식_

---

## 프로세스 스케줄링(Process Scheduling)

### 1. 핵심

운영체제(OS)는 CPU라는 자원을 여러 프로세스(또는 스레드) 사이에 효율적으로 나눠줘야 함.

이를 위해 **스케줄러(Scheduler)** 가 어떤 프로세스에 CPU를 줄지, 얼마나 줄지를 결정하는데 이 과정을 프로세스 스케줄링이라 부름.

대표적인 알고리즘: FCFS(First-Come-First-Served), SJF(Shortest Job First), Round Robin, Priority Scheduling.

### 2. Issue

CPU 자원은 한정적인데, 실행할 프로세스는 많음.

잘못된 스케줄링

- 대기 시간 증가 → 사용자 경험 악화

- 응답성 저하 → UI 렉, 입력 지연

- 우선순위 역전(Priority Inversion) → 중요한 작업이 늦게 실행됨

프론트엔드 관점

- 브라우저의 메인 스레드가 비슷한 상황에 직면.

- 렌더링, 사용자 이벤트 처리, JS 실행이 서로 CPU 시간을 두고 경쟁.

- 긴 JS 연산이 있으면 → 렌더링이 밀려서 화면이 멈춤.

### 3. 해결책

운영체제 레벨

- 공정성과 응답성을 위해 Round Robin + 우선순위 기반 스케줄링 자주 사용.

- I/O bound vs CPU bound 프로세스를 구분해서 처리.

프론트엔드 레벨

- 긴 연산은 잘게 나눠 실행 → setTimeout, requestIdleCallback 활용.

- 애니메이션은 브라우저 프레임 단위(requestAnimationFrame)로 분배.

- 백그라운드 연산은 Web Worker로 메인 스레드와 분리.

- React 18+에서는 내부적으로 Concurrent Mode를 이용해 "스케줄링"을 JS 레벨에서 최적화 (렌더링을 중단/재개).

### 4. QA

<QA children="프로세스 스케줄링과 JS 이벤트 루프의 차이점을 설명해보세요" />

<Table json='{"headers":["구분","프로세스 스케줄링","이벤트 루프"],"rows":[["주체","OS (커널)","JS 런타임 (브라우저, Node.js)"],["대상","여러 프로세스/스레드","한 스레드 안의 여러 태스크"],["방식","선점형(preemptive)","협력형(cooperative)"],["오버헤드","큼 (Context Switching)","작음 (콜백 실행)"]]}' />

<QA children="렌더링 최적화는 결국 어떤 스케줄링 문제를 해결하는 건가요?" />

브라우저는 렌더링, JS 실행, 사용자 입력 처리를 한정된 CPU 자원 안에서 번갈아 수행한다.

렌더링 최적화는 결국 이 작업들의 “스케줄링 효율”을 높이는 과정이다.

즉, 메인 스레드를 짧게 유지해 OS와 브라우저 스케줄러가 렌더링 타이밍을 확보하도록 돕는 것이다.

<Info isIcon={false}>
  프로세스 스케줄링은 CPU를 여러 프로세스에 효율적으로 배분하는 운영체제의 핵심
  기법이다. 프론트엔드에서 메인 스레드도 동일한 문제(경합)를 겪기 때문에, 작업
  분할 + 우선순위 제어 + 비동기 처리를 통해 성능 저하 없이 매끄러운 UI를
  유지하는 것이 실무 핵심이다.
</Info>
