---
title: "TanStack Query 도입기 — 서버 상태 관리 경험"
publishedAt: "2026-02-17"
summary: "TanStack Query를 처음 도입하면서 정리한 기본 개념"
tags: ["Next.js", "TanStack Query"]
---

요즘 프론트엔드 채용 공고를 보면 빠지지 않고 등장하는 이름이 있다. 바로 **TanStack Query**다.

그동안 이름만 들어봤지, 실제로 깊게 사용해본 적은 없었다. 그래서 이번 프로젝트에 직접 도입해보기로 했다.

이번 목표는 깊이 이해하는 것이 아니라, 일단 실제로 사용해보는 것이었다.

<ImageWithCaption
  src="/images/tanstack/tanstack-query.png"
  alt="TanStack"
  caption="출처 : "
  imgWidth="30%"
  sourceUrl="https://tanstack.com/"
  sourceLabel="TanStack"
/>

TanStack Query는 웹 애플리케이션에서 서버 상태(Server State)를 관리하기 위한 라이브러리다.  
단순히 API 호출을 도와주는 도구라기보다는, 데이터를 캐싱하고 최신 상태를 유지하며 로딩과 에러 상태까지 함께 관리해주는 구조에 가깝다.

---

## 도입 배경

React에서 서버 데이터를 다룰 때 보통 `useState`와 `useEffect`를 사용한다.  
하지만 프로젝트가 커질수록 몇 가지 문제가 반복적으로 발생했다.

여러 컴포넌트에서 동일한 API 요청이 발생했고, 데이터가 최신 상태인지 판단하기 어려웠다.  
로딩과 에러 상태를 매번 직접 관리해야 하는 점도 반복적인 작업처럼 느껴졌다.

공식 홈페이지에는 이런 문장이 있다.

> Less code, fewer edge cases.

이전에는 상태 변화에 따라 의도치 않게 API가 다시 호출되는 경우가 종종 있었다.

TanStack Query를 도입한 이후에는 데이터 요청의 기준이 컴포넌트 상태가 아니라 **Query Key**가 되었고,

요청과 캐싱의 흐름을 훨씬 명확하게 인지할 수 있게 됐다.

이러한 이유로 TanStack Query를 도입하게 됐다.

## 핵심 개념

TanStack Query를 처음 접하면 용어가 많아 보이지만, 실제로는 세 가지 개념을 중심으로 이해하면 된다.

### 1. Queries

데이터를 조회할 때 사용하는 개념이다.  
Query Key를 기준으로 캐싱이 이루어지며, 동일한 키를 사용하면 캐시된 데이터를 재사용한다.

```tsx
export const diaryKeys = {
  /**
   * 1. 최상위 루트 키 (all)
   * - 사용자가 로그아웃하거나 모든 일기 데이터를 한 번에 새로고침(Invalidate)해야 할 때,
   * queryClient.invalidateQueries({ queryKey: diaryKeys.all }) 한 줄로 해결 가능하다.
   */
  all: ["diary"] as const,

  /**
   * 2. 상세 정보 계층 (details & detail)
   */
  details: () => [...diaryKeys.all, "detail"] as const,
  detail: (id: string) => [...diaryKeys.details(), id] as const,

  /**
   * 3. 목록 및 아카이브 계층 (lists & list)
   */
  lists: () => [...diaryKeys.all, "list"] as const,
  list: (filters: { month?: string; q?: string }) =>
    [...diaryKeys.lists(), filters] as const,
};
```

Query Key는 데이터의 범위와 계층을 표현하는 구조다.

나는 일기 데이터를 다음과 같이 설계했다.

- `diaryKeys.all` → 모든 일기 데이터
- `diaryKeys.details()` → 상세 데이터 그룹
- `diaryKeys.detail(id)` → 특정 일기 상세
- `diaryKeys.lists()` → 목록 그룹
- `diaryKeys.list(filters)` → 필터 조건이 포함된 목록

이렇게 계층 구조로 나누면, 필요한 범위만 선택적으로 invalidate 할 수 있다.

예를 들어, 특정 일기만 새로고침할 수도 있고 전체 목록을 다시 불러올 수도 있다.

<br></br>

### 2. Mutations

데이터를 생성하거나 수정, 삭제할 때 사용하는 개념이다.

```tsx
return useMutation({
  mutationKey: ["diary", mode, diary_id ?? "new"],
  mutationFn: async (input: UpsertInput) => {
    const res =
      mode === "update"
        ? await updateDiaryAction({ diary_id, ...input })
        : await createDiaryAction(input);

    return unwrap(res);
  },

  onSuccess: async () => {
    await qc.invalidateQueries({ queryKey: homeKeys.all });
    await qc.invalidateQueries({ queryKey: diaryKeys.all });

    router.replace("/starLoad");
  },

  onError: (err) => {
    if (err instanceof ActionError) {
      console.error(err.payload.message);
      return;
    }
    console.error(err);
  },
});
```

이 Mutation은 일기 생성과 수정을 모두 처리한다.

1. `mutationKey`에는 모드(update/create)와 대상 ID를 포함했다.  
   어떤 작업이 실행되는지 명확히 구분하기 위함이다.

2. `mutationFn`에서는 mode 값에 따라  
   수정 API 또는 생성 API를 분기 처리한다.

3. 요청이 성공하면 `homeKeys`와 `diaryKeys`를 invalidate 한다.  
   일기 데이터가 변경되면 홈 화면과 상세 화면 모두 영향을 받기 때문이다.

4. 이후 `router.replace("/starLoad")`로 이동시켜  
   최신 데이터를 기준으로 다시 화면을 구성하도록 했다.

데이터 수정 이후에는 직접 상태를 바꾸지 않았다.

대신 관련 Query를 무효화해 TanStack Query가 최신 데이터를 다시 가져오도록 했다.

<br></br>

### 3. Query Invalidation

Query Invalidation은 캐시를 “오래된 상태”로 표시하는 기능이다.

직접 데이터를 수정하는 대신, 다시 요청하도록 유도하는 방식이다.

이 구조 덕분에 수정 이후의 상태를 수동으로 맞춰줄 필요가 없었고,

데이터 흐름도 단순하게 유지할 수 있었다.

---

## 데이터 상태 흐름

TanStack Query에서 데이터는 일정한 흐름을 가진다.

데이터가 최신 상태라고 판단되는 `Fresh` 단계가 있고, 시간이 지나면 `Stale` 상태로 전환된다.  
Stale 상태가 되면 화면에는 기존 데이터를 유지한 채 백그라운드에서 다시 요청이 발생한다.

`staleTime` 기본값은 0이다.

따라서 SSR로 전달된 데이터도 클라이언트에서 즉시 Stale 상태로 간주될 수 있다.

<br></br>

<Table
  data={{
    headers: ["상태", "설명", "동작 방식"],
    rows: [
      [
        "Fresh",
        "최신 데이터로 간주되는 상태",
        "staleTime이 만료되기 전까지 재요청 없이 캐시 데이터 사용",
      ],
      [
        "Stale",
        "오래된 데이터로 간주되는 상태",
        "화면에는 기존 데이터를 유지한 채 백그라운드에서 재요청 발생",
      ],
      [
        "Fetching",
        "데이터를 다시 가져오는 중인 상태",
        "네트워크 요청이 진행되며 완료 후 캐시 업데이트",
      ],
      [
        "Inactive",
        "현재 화면에서 사용되지 않는 상태",
        "gcTime 동안 메모리에 유지되며, 이후 GC 대상이 됨",
      ],
    ],
  }}
/>

<br></br>

상세 데이터는 자주 변경되지 않는다는 전제로 30분 동안 Fresh 상태를 유지하도록 설정했다.  
실제 적용 코드는 다음과 같다.

<br></br>

```tsx
if (diaryId) {
  prefetchPromises.push(
    queryClient.prefetchQuery({
      queryKey: diaryKeys.detail(diaryId),
      queryFn: () => getDiaryDetailServer(diaryId),
      staleTime: 1000 * 60 * 30,
    })
  );
}
```

## 캐시 전략 정리

`staleTime`은 데이터가 Fresh 상태를 유지하는 시간이다.

값을 적절히 설정하지 않으면 불필요한 재요청이 발생할 수 있다.

`gcTime`은 사용되지 않는 데이터를 메모리에 얼마나 보관할지 결정한다.

일정 시간이 지나면 캐시는 완전히 제거된다.

이번 구조에서는 `staleTime`만 전략적으로 조정하고, `gcTime`은 기본값을 유지했다.

## Prefetching

Prefetching은 사용자가 다음에 필요로 할 데이터를 미리 가져와 캐시에 저장하는 방식이다.

실제 화면 이동 시 로딩 없이 빠르게 데이터를 보여줄 수 있다.

Next.js 환경에서는 서버 컴포넌트에서 데이터를 미리 불러온 뒤, 클라이언트로 전달하는 방식으로 활용할 수 있다.

이 방식으로 SSR 이후 발생하던 중복 요청을 줄일 수 있었다.

<br></br>

```tsx
export default async function DiaryWritePage({
  searchParams,
}: {
  searchParams: Promise<{ diaryId?: string }>;
}) {
  const { diaryId } = await searchParams;
  const queryClient = getQueryClient();

  const prefetchPromises = [
    queryClient.prefetchQuery({
      queryKey: tagsKeys.list(),
      queryFn: getTagsServer,
      staleTime: 1000 * 60 * 30,
    }),
  ];

  if (diaryId) {
    prefetchPromises.push(
      queryClient.prefetchQuery({
        queryKey: diaryKeys.detail(diaryId),
        queryFn: () => getDiaryDetailServer(diaryId),
        staleTime: 1000 * 60 * 30,
      })
    );
  }

  return (
    <HydrationBoundary state={dehydrate(queryClient)}>
      <DiaryWrite diaryId={diaryId} />
    </HydrationBoundary>
  );
}
```

<br></br>

이 페이지에서는 서버에서 `queryClient`를 생성한 뒤, 필요한 데이터를 `prefetchQuery`로 먼저 불러온다.

- 태그 목록은 항상 필요하기 때문에 기본적으로 prefetch 한다.
- `diaryId`가 있는 경우에는 상세 데이터도 함께 불러온다.

이후 `dehydrate(queryClient)`로 캐시 상태를 직렬화해 `HydrationBoundary`를 통해 클라이언트로 전달한다.

클라이언트에서는 이미 캐시에 데이터가 존재하므로 추가 요청 없이 바로 화면을 렌더링할 수 있다.

---

## 정리

드디어 TanStack Query를 직접 사용해봤다.

이전에는 렌더링과 상태 변화에 의존해 API를 호출했지만, 이제는 Query Key를 기준으로 요청을 관리하게 되면서  
불필요한 호출이 줄어든 느낌이다. 물론 실제 서비스 환경에서 더 많은 테스트는 필요하다.

또한 브라우저 뒤로가기 이후 데이터가 갱신되지 않던 문제도 stale 상태와 refetch 동작을 이해하면서 자연스럽게 해결할 수 있었다.

이번 도입의 목표는 “일단 써보기”였지만, 이제는 캐싱 전략과 쿼리 설계를 더 효율적으로 다듬어볼 생각이다.
